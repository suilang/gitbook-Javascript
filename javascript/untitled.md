# 垃圾回收

JavaScript 中的内存管理是自动执行的，而且是不可见的。我们创建基本类型、对象、函数……所有这些都需要内存。

当不再需要某样东西时会发生什么? JavaScript 引擎是如何发现并清理它?

### 可达性

JavaScript 中内存管理的主要概念是可达性。

简单地说，“可达性” 值就是那些以某种方式可访问或可用的值，它们被保证存储在内存中。

**1. 有一组基本的固有可达值，由于显而易见的原因无法删除。例如:**

* 本地函数的局部变量和参数
* 当前嵌套调用链上的其他函数的变量和参数
* 全局变量
* 还有一些其他的，内部的

**这些值称为根。**

**2. 如果引用或引用链可以从根访问任何其他值，则认为该值是可访问的。**

例如，如果局部变量中有对象，并且该对象具有引用另一个对象的属性，则该对象被视为**可达性**， 它引用的那些也是可以访问的，详细的例子如下。

JavaScript 引擎中有一个后台进程称为[垃圾回收器](https://en.wikipedia.org/wiki/Garbage_collection_%28computer_science%29)，它监视所有对象，并删除那些不可访问的对象。

### 一个简单的例子

下面是最简单的例子:

```text
// user 具有对象的引用
let user = {
  name: "John"
};
```

[![&#x56FE;&#x7247;&#x63CF;&#x8FF0;](https://camo.githubusercontent.com/4414dba02ec78d721b728469d967f97923388744/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031392f332f33312f313639643230346464666539666261373f773d31323026683d31333326663d706e6726733d34373637)](https://camo.githubusercontent.com/4414dba02ec78d721b728469d967f97923388744/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031392f332f33312f313639643230346464666539666261373f773d31323026683d31333326663d706e6726733d34373637)

这里箭头表示一个对象引用。全局变量`“user”`引用对象 `{name:“John”}` \(为了简洁起见，我们将其命名为**John**\)。John 的 `“name”` 属性存储一个基本类型，因此它被绘制在对象中。

如果 `user` 的值被覆盖，则引用丢失:

```text
user = null;
```

[![&#x56FE;&#x7247;&#x63CF;&#x8FF0;](https://camo.githubusercontent.com/7242df6de7fee9cc19b6b4f4c01103246e22d61b/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031392f332f33312f313639643230346465313733636263313f773d31393426683d31353326663d706e6726733d36303832)](https://camo.githubusercontent.com/7242df6de7fee9cc19b6b4f4c01103246e22d61b/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031392f332f33312f313639643230346465313733636263313f773d31393426683d31353326663d706e6726733d36303832)

现在 **John** 变成不可达的状态，没有办法访问它，没有对它的引用。垃圾回收器将丢弃 **John** 数据并释放内存。

### 两个引用

现在让我们假设我们将引用从 `user` 复制到 `admin`:

```text
// user具有对象的引用
let user = {
  name: "John"
};

let admin = user;
```

[![&#x56FE;&#x7247;&#x63CF;&#x8FF0;](https://camo.githubusercontent.com/292b17abed773b6601362838a0b105777d48ac30/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031392f332f33312f313639643230346463666561373433313f773d31323226683d31323726663d706e6726733d35343339)](https://camo.githubusercontent.com/292b17abed773b6601362838a0b105777d48ac30/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031392f332f33312f313639643230346463666561373433313f773d31323226683d31323726663d706e6726733d35343339)

现在如果我们做同样的事情:

```text
user = null;
```

该对象仍然可以通过 `admin` 全局变量访问，所以它在内存中。如果我们也覆盖`admin`，那么它可以被释放。

### 相互关联的对象

现在来看一个更复杂的例子， family 对象：

```text
function marry (man, woman) {
  woman.husban = man;
  man.wife = woman;

  return {
    father: man,
    mother: woman
  }
}

let family = marry({
  name: "John"
}, {
  name: "Ann"
})
```

函数 `marry` 通过给两个对象彼此提供引用来“联姻”它们，并返回一个包含两个对象的新对象。

产生的内存结构:

[![&#x56FE;&#x7247;&#x63CF;&#x8FF0;](https://camo.githubusercontent.com/b47d2e17298744737e1be9c776a79b3760088a50/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031392f332f33312f313639643230346464363738623766343f773d33323926683d31383526663d706e6726733d3133353631)](https://camo.githubusercontent.com/b47d2e17298744737e1be9c776a79b3760088a50/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031392f332f33312f313639643230346464363738623766343f773d33323926683d31383526663d706e6726733d3133353631)

到目前为止，所有对象都是可访问的。

现在让我们删除两个引用:

```text
delete family.father;
delete family.mother.husband;
```

[![&#x56FE;&#x7247;&#x63CF;&#x8FF0;](https://camo.githubusercontent.com/b1560f52fb91f6b2abb40a84e244fd480a11d14a/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031392f332f33312f313639643230346562353063363266313f773d33323926683d31383826663d706e6726733d3135313338)](https://camo.githubusercontent.com/b1560f52fb91f6b2abb40a84e244fd480a11d14a/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031392f332f33312f313639643230346562353063363266313f773d33323926683d31383826663d706e6726733d3135313338)

仅仅删除这两个引用中的一个是不够的，因为所有对象仍然是可访问的。

但是如果我们把这两个都删除，那么我们可以看到 John 不再有传入的引用:

[![&#x56FE;&#x7247;&#x63CF;&#x8FF0;](https://camo.githubusercontent.com/73b3e6849356e6d024ba49a7c8895b7236e1068b/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031392f332f33312f313639643230346562653234396365333f773d33393026683d32303526663d706e6726733d3131353034)](https://camo.githubusercontent.com/73b3e6849356e6d024ba49a7c8895b7236e1068b/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031392f332f33312f313639643230346562653234396365333f773d33393026683d32303526663d706e6726733d3131353034)

输出引用无关紧要。只有传入的对象才能使对象可访问，因此，**John** 现在是不可访问的，并将从内存中删除所有不可访问的数据。

垃圾回收之后：

[![&#x56FE;&#x7247;&#x63CF;&#x8FF0;](https://camo.githubusercontent.com/41fb1af5ce9381a75b6027677bdeebc12ff31298/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031392f332f33312f313639643230346562623235326231613f773d31323026683d32303026663d706e6726733d37333935)](https://camo.githubusercontent.com/41fb1af5ce9381a75b6027677bdeebc12ff31298/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031392f332f33312f313639643230346562623235326231613f773d31323026683d32303026663d706e6726733d37333935)

### 无法访问的数据块

有可能整个相互连接的对象变得不可访问并从内存中删除。

源对象与上面的相同。然后:

```text
family = null;
```

内存中的图片变成:

[![&#x56FE;&#x7247;&#x63CF;&#x8FF0;](https://camo.githubusercontent.com/5f9c713183931c42c2367d25337c6f82ef2f11b8/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031392f332f33312f313639643230346561343736373965383f773d34303526683d32333926663d706e6726733d3134323834)](https://camo.githubusercontent.com/5f9c713183931c42c2367d25337c6f82ef2f11b8/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031392f332f33312f313639643230346561343736373965383f773d34303526683d32333926663d706e6726733d3134323834)

这个例子说明了可达性的概念是多么重要。

很明显，John和Ann仍然链接在一起，都有传入的引用。但这还不够。

“family”对象已经从根上断开了链接，不再有对它的引用，因此下面的整个块变得不可到达，并将被删除。

### 内部算法

基本的垃圾回收算法称为\*\*“标记-清除”\*\*，定期执行以下“垃圾回收”步骤:

* 垃圾回收器获取根并\*\*“标记”\*\*\(记住\)它们。
* 然后它访问并“标记”所有来自它们的引用。
* 然后它访问标记的对象并标记它们的引用。所有被访问的对象都被记住，以便以后不再访问同一个对象两次。
* 以此类推，直到有未访问的引用\(可以从根访问\)为止。
* 除标记的对象外，所有对象都被删除。

例如，对象结构如下:

[![&#x56FE;&#x7247;&#x63CF;&#x8FF0;](https://camo.githubusercontent.com/5972e8bb28fea046e303cabd0b64989cd83b735e/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031392f332f33312f313639643230346636646366613638383f773d33373326683d31383926663d706e6726733d39373331)](https://camo.githubusercontent.com/5972e8bb28fea046e303cabd0b64989cd83b735e/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031392f332f33312f313639643230346636646366613638383f773d33373326683d31383926663d706e6726733d39373331)

我们可以清楚地看到右边有一个“不可到达的块”。现在让我们看看\*\*“标记并清除”\*\*垃圾回收器如何处理它。

**第一步标记根**

[![&#x56FE;&#x7247;&#x63CF;&#x8FF0;](https://camo.githubusercontent.com/2377cce1dc531274d3cad16b7431a192369d16af/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031392f332f33312f313639643230346635643663303866313f773d33373326683d31383926663d706e6726733d3130333436)](https://camo.githubusercontent.com/2377cce1dc531274d3cad16b7431a192369d16af/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031392f332f33312f313639643230346635643663303866313f773d33373326683d31383926663d706e6726733d3130333436)

**然后标记他们的引用**

[![&#x56FE;&#x7247;&#x63CF;&#x8FF0;](https://camo.githubusercontent.com/8227b213b7061b0c5bad5437ecfa4c47a4a2317b/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031392f332f33312f313639643230353032396136363163353f773d33373326683d31383926663d706e6726733d3130383432)](https://camo.githubusercontent.com/8227b213b7061b0c5bad5437ecfa4c47a4a2317b/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031392f332f33312f313639643230353032396136363163353f773d33373326683d31383926663d706e6726733d3130383432)

以及子孙代的引用:

[![&#x56FE;&#x7247;&#x63CF;&#x8FF0;](https://camo.githubusercontent.com/7f314d2855804b5a4930c215993ecc19ea5a5910/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031392f332f33312f313639643230346664373961613838303f773d33373326683d31383926663d706e6726733d3131313535)](https://camo.githubusercontent.com/7f314d2855804b5a4930c215993ecc19ea5a5910/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031392f332f33312f313639643230346664373961613838303f773d33373326683d31383926663d706e6726733d3131313535)

现在进程中不能访问的对象被认为是不可访问的，将被删除:

[![&#x56FE;&#x7247;&#x63CF;&#x8FF0;](https://camo.githubusercontent.com/51f6abe9d8575feed4a6dd456b23e512e05cfcaf/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031392f332f33312f313639643230353030623830666465613f773d33373926683d31393226663d706e6726733d3133393333)](https://camo.githubusercontent.com/51f6abe9d8575feed4a6dd456b23e512e05cfcaf/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031392f332f33312f313639643230353030623830666465613f773d33373926683d31393226663d706e6726733d3133393333)

这就是垃圾收集的工作原理。JavaScript引擎应用了许多优化，使其运行得更快，并且不影响执行。

一些优化:

* **分代回收**——对象分为两组:“新对象”和“旧对象”。许多对象出现，完成它们的工作并迅速结 ，它们很快就会被清理干净。那些活得足够久的对象，会变“老”，并且很少接受检查。
* **增量回收**——如果有很多对象，并且我们试图一次遍历并标记整个对象集，那么可能会花费一些时间，并在执行中会有一定的延迟。因此，引擎试图将垃圾回收分解为多个部分。然后，各个部分分别执行。这需要额外的标记来跟踪变化，这样有很多微小的延迟，而不是很大的延迟。
* **空闲时间收集**——垃圾回收器只在 CPU 空闲时运行，以减少对执行的可能影响。

